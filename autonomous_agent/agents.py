from typing import List, Dict
from autonomous_agent.llm_client import huggingface_chat_completion_create_retrying
from autonomous_agent.memory import DenseRetriever
from autonomous_agent.schemas import Task


def task_creation_agent(objective: str, result: Dict, task_description: str, task_list: List[str], host: str, port: int):
    prompt = f"""
    You are a task creation AI that uses the result of an execution agent to create new tasks with the following objective: {objective},
    The last completed task has the result: {result}.
    This result was based on this task description: {task_description}. These are incomplete tasks: {', '.join(task_list)}.
    Based on the result, create new tasks to be completed by the AI system that do not overlap with incomplete tasks.
    Return the tasks as an array."""
    messages = [{"role": "system", "content": prompt}]
    response = huggingface_chat_completion_create_retrying(messages=messages, host=host, port=port)["choices"][0]["message"]["content"]

    new_tasks = response.split("\n") if "\n" in response else [response]
    return [{"task_name": task_name} for task_name in new_tasks]


def prioritization_agent(objective, task_list, this_task_id: int, host: str,  port: int):
    task_names = [t.task_name for t in task_list]
    next_task_id = int(this_task_id) + 1
    prompt = f"""
    You are a task prioritization AI tasked with cleaning the formatting of and reprioritizing the following tasks: {task_names}.
    Consider the ultimate objective of your team:{objective}.
    Do not remove any tasks. Return the result as a numbered list, like:
    #. First task
    #. Second task
    Start the task list with number {next_task_id}."""
    messages = [{"role": "system", "content": prompt}]
    response = huggingface_chat_completion_create_retrying(messages=messages, host=host, port=port)["choices"][0]["message"]["content"]
    new_tasks = response.split("\n") if "\n" in response else [response]
    for task_string in new_tasks:
        task_parts = task_string.strip().split(".", 1)
        if len(task_parts) == 2:
            task_id = task_parts[0].strip()
            task_name = task_parts[1].strip()
            task_list.append(Task(**{"task_id": task_id, "task_name": task_name}))


def execution_agent(objective: str, task: str, top_k: int, host: str, port: int, retriever: DenseRetriever) -> str:
    """
    Executes a task based on the given objective and previous context.

    Args:
        objective (str): The objective or goal for the AI to perform the task.
        task (str): The task to be executed by the AI.

    Returns:
        str: The response generated by the AI for the given task.

    """

    context = context_agent(query=objective, top_k=top_k, retriever=retriever)
    prompt = f"""
    You are an AI who performs one task based on the following objective: {objective}\n.
    Take into account these previously completed tasks: {context}\n.
    Your task: {task}\nResponse:"""
    messages = [{"role": "system", "content": prompt}]
    response = huggingface_chat_completion_create_retrying(messages=messages, host=host, port=port, temperature=0.7, max_tokens=2000)
    return response["choices"][0]["message"]["content"]


def context_agent(query: str, top_k: int, retriever: DenseRetriever) -> List[str]:
    """
    Retrieves context for a given query from an index of tasks.

    Args:
        query (str): The query or objective for retrieving context.
        n (int): The number of top results to retrieve.

    Returns:
        list: A list of tasks as context for the given query, sorted by relevance.

    """
    results = retriever.search(query, top_k)
    sorted_results = sorted(results, key=lambda x: x["score"], reverse=True)
    return [item["task_name"] for item in sorted_results]
